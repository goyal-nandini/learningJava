âœ… Time and Space Complexity Summary

| Method            | TC (Array Queue)       | SC (Array Queue)         | TC (LL Queue)          | SC (LL Queue)           |
| ----------------- | ---------------------- | ------------------------ | ---------------------- | ----------------------- |
| `offer()`         | O(1)                   | O(1)                     | O(1)                   | O(1)                    |
| `poll()`          | O(1)                   | O(1)                     | O(1)                   | O(1)                    |
| `peek()`          | O(1)                   | O(1)                     | O(1)                   | O(1)                    |
| `size()`          | O(1)                   | O(1)                     | O(1)                   | O(1)                    |
| `display()`       | O(n)                   | O(1)                     | O(n)                   | O(1)                    |
| **Overall class** | **O(1) per operation** | **O(n)** (array storage) | **O(1) per operation** | **O(n)** (linked nodes) |


doubt on tc in conversion due to nested loop
solution to it:
ğŸ‘ï¸Even if an inner while loop pops many items during one iterationâ€¦

â¡ Those items will never be popped again later
â¡ So work done per element is constant amortized ğŸ«£(i've seen it in lc que ->
Implementation of queue using stack approach2)

ğŸ” Quick Mental Model Trick
Ask this question whenever nested loops appear:

Can the inner loop do more total operations than N across the whole function? ğŸ‘£ğŸ˜ƒ
âœ If NO â†’ time complexity stays O(n)

âœ… Simple One-Liner to Remember
    If inner loop operations donâ€™t repeat for the same element â†’ O(n)

    If inner loop redoes work fully for each outer iteration â†’ O(nÂ²)

âœ… So Your Thinking Was Right âœ…
You assumed O(nÂ²) â†’ thatâ€™s the safest starting assumption.
Then we applied reasoning â†’ discovered amortized O(n).

Thatâ€™s exactly how DSA intuition improves. ğŸš€ğŸ”¥